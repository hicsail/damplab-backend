# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

"""Services supported by the DampLab"""
type DampLabService {
  """unique database generated ID"""
  id: ID!

  """Human readable name of the service"""
  name: String!

  """URL to the icon of the service"""
  icon: String!

  """Parameters that are part of the service"""
  parameters: JSON!

  """If there are grouped parameters"""
  paramGroups: JSON

  """List of services this service can connect to"""
  allowedConnections: [DampLabService!]!

  """The by-product of the service"""
  result: JSON

  """The expected fields in the result of the service"""
  resultParams: [String!]
  description: String!
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON

"""
Represents a single node in a workflow. A node is a service with the cooresponding parameters populated.
"""
type WorkflowNode {
  """Database generated ID"""
  _id: ID!

  """ID used in identify the node in the workflow"""
  id: ID!

  """Human readable name of the service"""
  label: String!

  """The service this node represents"""
  service: DampLabService!

  """Additional instructions for this portion of the workflow"""
  additionalInstructions: String!

  """Parameters defined earlier in the graph"""
  formData: JSON!

  """React Flow representation of the graph for re-generating"""
  reactNode: JSON!

  """Where in the process is the current node"""
  state: WorkflowNodeState!
}

enum WorkflowNodeState {
  QUEUED
  IN_PROGRESS
  COMPLETE
}

"""Represents a single edge in a workflow"""
type WorkflowEdge {
  """ID used in identify the edge in the workflow"""
  id: ID!

  """The source node of the edge"""
  source: WorkflowNode!

  """The target node of the edge"""
  target: WorkflowNode!

  """React Flow representation of the graph for re-generating"""
  reactEdge: JSON!
}

"""
Represents a series of services that are connected together to form a workflow.
"""
type Workflow {
  id: ID!

  """The nodes in the workflow"""
  nodes: [WorkflowNode!]!

  """The edges in the workflow"""
  edges: [WorkflowEdge!]!

  """Where in the process the Workflow is"""
  state: WorkflowState!

  """The name of the workflow"""
  name: String!
}

enum WorkflowState {
  QUEUED
  IN_PROGRESS
  COMPLETE
}

"""Represents a category of DampLab services"""
type Category {
  """unique database generated ID"""
  id: ID!
  label: String!

  """List of DampLab services in this category"""
  services: [DampLabService!]!
}

type Bundle {
  """unique database generated id"""
  id: ID!
  label: String!
  icon: String!
  services: [DampLabService!]!
}

"""Jobs encapsulate many workflows that were submitted together"""
type Job {
  id: ID!

  """Human readable name of the workflow"""
  name: String!

  """Username of the person who submitted the job"""
  username: String!

  """The institute the user is from"""
  institute: String!

  """The email address of the user"""
  email: String!

  """The workflows that were submitted together"""
  workflows: [Workflow!]!

  """The date the job was submitted"""
  submitted: DateTime!

  """Additional information the user provided"""
  notes: String

  """Where in the Job life cycle this Job is"""
  state: JobState!
  comments: [Comment!]!
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

enum JobState {
  CREATING
  SUBMITTED
  CHANGES_REQUESTED
  ACCEPTED
  WAITING_FOR_SOW
  QUEUED
  IN_PROGRESS
  COMPLETE
  REJECTED
}

"""Comments describe why a job was accepted/rejected """
type Comment {
  """Comment text message """
  message: String!
}

type Annotation {
  start: Float!
  end: Float!
  type: String!
  description: String
}

type Sequence {
  id: ID!
  name: String!
  type: String!
  seq: String!
  annotations: [Annotation!]!
  userId: String!
  mpiId: String!
  created_at: DateTime!
  updated_at: DateTime!
}

type HazardHits {
  name: String!
  description: String!
  is_wild_type: Boolean!
  references: [String!]!
}

type ScreeningResult {
  id: ID!
  sequence: Sequence!
  region: String!
  threats: [HazardHits!]!
  status: String!
  userId: String!
  created_at: DateTime!
  updated_at: DateTime!
}

type Query {
  services: [DampLabService!]!
  workflowById(id: ID!): Workflow
  getWorkflowByState(state: WorkflowState!): [Workflow!]!
  categories: [Category!]!
  bundles: [Bundle!]!
  jobByName(name: String!): Job
  jobById(id: ID!): Job
  jobByWorkflowId(workflow: ID!): Job!
  sequences: [Sequence!]!
  sequence(id: String!): Sequence
}

type Mutation {
  updateService(service: ID!, changes: ServiceChange!): DampLabService!
  deleteService(service: ID!): Boolean!
  createService(service: CreateService!): DampLabService!
  changeWorkflowState(workflow: ID!, newState: WorkflowState!): Workflow!
  changeWorkflowNodeState(workflowNode: ID!, newState: WorkflowNodeState!): WorkflowNode!
  updateCategory(category: ID!, changes: CategoryChange!): Category!
  deleteCategory(category: ID!): Boolean!
  createCategory(category: CreateCategory!): Category!
  updateBundle(bundle: ID!, changes: BundleChange!): Bundle!
  createJob(createJobInput: CreateJob!): Job!
  changeJobState(job: ID!, newState: JobState!): Job!
  createComment(newComment: CreateComment!): Comment!

  """Drop the database"""
  clearDatabase: Boolean!

  """Load in services, categories, and bundles"""
  loadData(services: [ServiceInput!]!, categories: [CategoryInput!]!, bundles: [BundleInput!]!): Boolean!
  createSequence(input: CreateSequenceInput!): Sequence!
  screenSequence(input: ScreeningInput!): ScreeningResult!
  screenSequencesBatch(input: BatchScreeningInput!): [ScreeningResult!]!
  deleteSequence(id: String!): Boolean!
}

input ServiceChange {
  """Human readable name of the service"""
  name: String

  """URL to the icon of the service"""
  icon: String

  """Parameters that are part of the service"""
  parameters: JSON

  """If there are grouped parameters"""
  paramGroups: JSON

  """The by-product of the service"""
  result: JSON

  """The expected fields in the result of the service"""
  resultParams: [String!]
  description: String
  allowedConnections: [ID!]
}

input CreateService {
  """Human readable name of the service"""
  name: String!

  """URL to the icon of the service"""
  icon: String!

  """Parameters that are part of the service"""
  parameters: JSON!

  """If there are grouped parameters"""
  paramGroups: JSON

  """The by-product of the service"""
  result: JSON

  """The expected fields in the result of the service"""
  resultParams: [String!]
  description: String!
  allowedConnections: [ID!]!
}

input CategoryChange {
  label: String
  services: [ID!]
}

input CreateCategory {
  label: String!
  services: [ID!]!
}

input BundleChange {
  label: String
  icon: String
  services: [ID!]
}

input CreateJob {
  """Human readable name of the workflow"""
  name: String!

  """Username of the person who submitted the job"""
  username: String!

  """The institute the user is from"""
  institute: String!

  """The email address of the user"""
  email: String!

  """Additional information the user provided"""
  notes: String

  """The workflows that were submitted together"""
  workflows: [AddWorkflowInput!]!
}

input AddWorkflowInput {
  """The name of the workflow"""
  name: String!

  """The nodes in the workflow"""
  nodes: [AddNodeInput!]!

  """The edges in the workflow"""
  edges: [AddEdgeInput!]!
}

input AddNodeInput {
  """ID used in identify the node in the workflow"""
  id: ID!

  """Human readable name of the service"""
  label: String!

  """Additional instructions for this portion of the workflow"""
  additionalInstructions: String!

  """Parameters defined earlier in the graph"""
  formData: JSON!

  """React Flow representation of the graph for re-generating"""
  reactNode: JSON!

  """The ID of the service this node is a part of"""
  serviceId: ID!
}

input AddEdgeInput {
  """ID used in identify the edge in the workflow"""
  id: ID!

  """React Flow representation of the graph for re-generating"""
  reactEdge: JSON!

  """The ID of the source node, this is the workflow ID"""
  source: ID!

  """The ID of the destination node, this is the workflow ID"""
  target: ID!
}

input CreateComment {
  """Comment text message """
  message: String!

  """Job which the comment is under"""
  job: ID!
}

input ServiceInput {
  """Human assigned ID"""
  id: String!

  """Name of the service"""
  name: String!

  """The icon image"""
  icon: String!

  """Parameters required of the service"""
  parameters: JSON!

  """Array of human assigned IDs"""
  allowedConnections: [String!]!

  """List of categories the service is a part of"""
  categories: [String!]!

  """The result of the service"""
  result: JSON
  description: String!
  resultParams: [String!]
  paramGroups: JSON
}

input CategoryInput {
  """Human assigned ID"""
  id: String!

  """Name of the category"""
  label: String!
}

input BundleInput {
  """Human assigned ID"""
  id: String!

  """Bundle name"""
  label: String!

  """Icon of the bundle"""
  icon: String!

  """List of services represented using the human assigned ID"""
  services: [String!]!
}

input CreateSequenceInput {
  name: String!
  type: String!
  seq: String!
  annotations: [AnnotationInput!]
}

input AnnotationInput {
  start: Float!
  end: Float!
  type: String!
  description: String
}

input ScreeningInput {
  sequenceId: String!
  region: String!
}

input BatchScreeningInput {
  sequenceIds: [String!]!
  region: String!
}

type Subscription {
  screeningStatus(sequenceId: String!): ScreeningResult!
}